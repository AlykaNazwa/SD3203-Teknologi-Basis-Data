---
title: "Three Ways of Storing and Accessing Lots of Images in Python"
author: "Alayka Nazwa_121450016_RA"
date: "2024-04-21"
output:
  pdf_document: default
  html_document: default
---

Kode berikut membuka setiap berkas batch dan memuat semua gambar ke dalam larik NumPy:


import numpy as np
import pickle
from pathlib import Path

# Path to the unzipped CIFAR data
data_dir = Path("/content/cifar-10-batches-py-20240421T062357Z-001.zip")

# Unpickle function provided by the CIFAR hosts
def unpickle(file):
    with open(file, "rb") as fo:
        dict = pickle.load(fo, encoding="bytes")
    return dict

images, labels = [], []
for batch in data_dir.glob("data_batch_*"):
    batch_data = unpickle(batch)
    for i, flat_im in enumerate(batch_data[b"data"]):
        im_channels = []
        # Each image is flattened, with channels in order of R, G, B
        for j in range(3):
            im_channels.append(
                flat_im[j * 1024 : (j + 1) * 1024].reshape((32, 32))
            )
        # Reconstruct the original image
        images.append(np.dstack((im_channels)))
        # Save the label
        labels.append(batch_data[b"labels"][i])

        
print("Loaded CIFAR-10 training set:")
print(f" - np.shape(images)     {np.shape(images)}")
print(f" - np.shape(labels)     {np.shape(labels)}")


#Output 
Loaded CIFAR-10 training set:
 - np.shape(images)     (0,)
 - np.shape(labels)     (0,)



#Kode ini bertujuan untuk membuka setiap berkas batch dari dataset CIFAR-10 yang telah di-unzip dan memuat semua gambar ke dalam larik NumPy.

1. Impor pustaka yang diperlukan:
   - `numpy` digunakan untuk manipulasi data larik.
   - `pickle` digunakan untuk membaca berkas biner yang dihasilkan oleh Python.
   - `Path` dari modul `pathlib` digunakan untuk memanipulasi jalur berkas.

2. Definisikan jalur menuju direktori data CIFAR-10.

3. Didefinisikan fungsi `unpickle` untuk membuka berkas batch CIFAR-10 yang di-provided oleh penyelenggara CIFAR. Fungsi ini membaca berkas menggunakan `pickle.load()` dan mengembalikan kamus data.

4. Inisialisasi larik kosong `images` dan `labels` untuk menyimpan gambar dan label dari dataset CIFAR-10.

5. Lakukan iterasi melalui setiap berkas batch dalam direktori data dengan menggunakan metode `.glob()` dari objek `Path` untuk mencocokkan pola nama berkas yang dimulai dengan "data_batch_".

6. Buka setiap berkas batch menggunakan fungsi `unpickle()` yang telah didefinisikan sebelumnya.

7. Di dalam loop batch, iterasi melalui setiap gambar dalam batch dan setiap kanal warna dalam gambar.
   - Gambar-gambar dalam CIFAR-10 dataset disimpan dalam format array "flattened" di mana setiap gambar terdiri dari 3072 elemen (32x32 piksel x 3 saluran warna). Loop ini membagi array gambar tersebut menjadi tiga saluran warna: merah (R), hijau (G), dan biru (B).
   - Setiap saluran warna diubah bentuk menjadi matriks 32x32 menggunakan metode `.reshape()`.
   - Ketiga saluran warna tersebut digabungkan kembali menggunakan `np.dstack()` untuk membentuk kembali gambar asli.

8. Setiap gambar yang telah dibentuk kembali dimasukkan ke dalam larik `images`, dan label yang sesuai dimasukkan ke dalam larik `labels`.

9. Setelah loop selesai, cetak bentuk larik `images` dan `labels`.

Output yang ditampilkan menunjukkan bahwa tidak ada gambar atau label yang dimuat. Hal ini disebabkan oleh perubahan pada struktur dataset CIFAR-10 atau kesalahan dalam pemilihan jalur data.

#Setup for Storing Images on Disk


$ pip install Pillow

Perintah pip install Pillow digunakan untuk menginstal pustaka Python yang disebut Pillow. Pillow adalah pustaka yang populer digunakan untuk pemrosesan gambar dalam lingkungan Python.

#Getting Started With LMDB

 pip install lmdb

 Perintah pip install lmdb digunakan untuk menginstal pustaka Python yang disebut LMDB (Lightning Memory-Mapped Database). LMDB adalah basis data berorientasi kunci yang memanfaatkan pemetaan memori untuk menyimpan dan mengakses data dengan cepat.
 
#Getting Started With HDF5

 pip install h5py

Perintah pip install h5py digunakan untuk menginstal pustaka Python yang disebut h5py. h5py adalah pustaka Python yang menyediakan antarmuka untuk bekerja dengan format file Hierarchical Data Format version 5 (HDF5) menggunakan API berorientasi objek.

#Storing a Single Image
#
from pathlib import Path

disk_dir = Path("data/disk/")
lmdb_dir = Path("data/lmdb/")
hdf5_dir = Path("data/hdf5/")


1. Impor Path dari pathlib:Ini mengimpor kelas Path dari pustaka pathlib, yang memungkinkan kita membuat dan memanipulasi objek jalur berkas.

2. Membuat objek Path untuk direktori disk, LMDB, dan HDF5: - - -disk_dir, lmdb_dir, dan hdf5_dir adalah objek jalur yang mewakili direktori di sistem berkas.
-Path() digunakan untuk membuat objek jalur dari string yang diberikan. Dalam hal ini, string tersebut adalah jalur relatif dari direktori saat ini ke direktori yang ditentukan.
Objek jalur akan mewakili jalur di sistem berkas yang digunakan dalam kode selanjutnya, seperti membuat, membaca, atau menulis berkas.

#
disk_dir.mkdir(parents=True, exist_ok=True)
lmdb_dir.mkdir(parents=True, exist_ok=True)
hdf5_dir.mkdir(parents=True, exist_ok=True)

1. Membuat direktori diskritori dengan mkdir(): 
-mkdir() adalah metode yang digunakan untuk membuat direktori baru di sistem berkas.
-Argumen parents=True menunjukkan bahwa jika direktori induk dari direktori yang akan dibuat tidak ada, maka metode mkdir() akan membuatnya juga. Dalam konteks ini, parents=True memungkinkan pembuatan direktori yang bersarang, seperti saat direktori "data" belum ada, maka akan dibuat bersamaan dengan direktori "disk".
-Argumen exist_ok=True menunjukkan bahwa jika direktori yang akan dibuat sudah ada, maka tidak akan muncul pesan kesalahan. Dengan kata lain, jika direktori "disk" sudah ada, perintah ini tidak akan memunculkan kesalahan, sehingga tidak ada tindakan yang diambil.

2. Membuat direktori lmdb dan hdf5 dengan mkdir():
-pembuatan direktori yang berbeda: lmdb dan hdf5. Jadi, perintah ini akan membuat direktori "lmdb" dan "hdf5" dengan pengaturan yang sama dengan direktori "disk".

#Storing to Disk

from PIL import Image
import csv

def store_single_disk(image, image_id, label):
    """ Stores a single image as a .png file on disk.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    Image.fromarray(image).save(disk_dir / f"{image_id}.png")

    with open(disk_dir / f"{image_id}.csv", "wt") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        writer.writerow([label])

1. Impor pustaka yang diperlukan:
-PIL digunakan untuk memanipulasi gambar.
csv digunakan untuk menulis label gambar ke dalam file CSV.

2. Definisi fungsi store_single_disk:
-Ini adalah definisi fungsi yang menerima tiga parameter: image, image_id, dan label.
-image adalah array gambar dengan bentuk (32, 32, 3) yang akan disimpan.
-image_id adalah ID unik untuk gambar.
-Label adalah label untuk gambar tersebut.

3. Menyimpan gambar sebagai file .png di -disk:Image.fromarray(image) mengonversi array gambar menjadi objek gambar dari pustaka PIL.
-save(disk_dir / f"{image_id}.png") menyimpan gambar ke dalam file -png dengan nama file yang sesuai dengan image_id, dalam direktori yang ditentukan oleh disk_dir.

4.Menyimpan label sebagai file .csv di disk:
-open(disk_dir / f"{image_id}.csv", "wt") membuka file CSV untuk ditulis dengan nama file yang sesuai dengan image_id, dalam direktori yang ditentukan oleh disk_dir.
-csv.writer() digunakan untuk membuat objek penulis CSV.
-writer.writerow([label]) menulis label gambar ke dalam file CSV. -Label tersebut diwakili sebagai satu elemen dalam list.

#Storing to LMDB

class CIFAR_Image:
    def __init__(self, image, label):
        # Dimensions of image for reconstruction - not really necessary 
        # for this dataset, but some datasets may include images of 
        # varying sizes
        self.channels = image.shape[2]
        self.size = image.shape[:2]

        self.image = image.tobytes()
        self.label = label

    def get_image(self):
        """ Returns the image as a numpy array. """
        image = np.frombuffer(self.image, dtype=np.uint8)
        return image.reshape(*self.size, self.channels)

1. Definisi kelas CIFAR_Image:

2. Metode __init__:
-Metode __init__ adalah metode khusus yang dipanggil saat sebuah objek kelas dibuat.
-Parameter image adalah array gambar, dan label adalah label untuk gambar tersebut.

3. Menginisialisasi atribut:
-Atribut channels diinisialisasi dengan jumlah saluran warna dalam gambar.
-Atribut size diinisialisasi dengan dimensi gambar (tinggi dan lebar).

4. Mengonversi gambar ke dalam bentuk bytes: 
-Gambar diubah menjadi bentuk byte menggunakan metode tobytes(), sehingga dapat disimpan atau ditransmisikan dengan lebih mudah.

5. Menyimpan label:Label gambar disimpan dalam atribut label.

6. Metode get_image:
-Ini adalah metode untuk mengembalikan gambar sebagai larik NumPy.
Menggunakan np.frombuffer() untuk mengonversi byte kembali menjadi larik NumPy dengan tipe data uint8.
-Reshape larik kembali ke bentuk aslinya menggunakan reshape(), dengan dimensi yang disimpan di atribut size dan jumlah saluran warna diambil dari atribut channels.

Dengan tiga poin tersebut diingat, mari kita lihat kode untuk menyimpan sebuah gambar tunggal ke dalam LMDB:


import lmdb
import pickle

def store_single_lmdb(image, image_id, label):
    """ Stores a single image to a LMDB.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    map_size = image.nbytes * 10

    # Create a new LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), map_size=map_size)

    # Start a new write transaction
    with env.begin(write=True) as txn:
        # All key-value pairs need to be strings
        value = CIFAR_Image(image, label)
        key = f"{image_id:08}"
        txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()

1. Impor pustaka yang diperlukan:
-lmdb adalah pustaka Python untuk bekerja dengan basis data berorientasi kunci menggunakan LMDB.
-pickle adalah pustaka Python untuk serialisasi dan deserialisasi objek 

2. Definisi fungsi store_single_lmdb:
-Ini adalah definisi fungsi yang menerima tiga parameter: image, image_id, dan label.
-image adalah array gambar dengan bentuk (32, 32, 3) yang akan disimpan.
-image_id adalah ID unik untuk gambar.
-label adalah label untuk gambar tersebut.

3. Menghitung ukuran peta untuk LMDB:
-image.nbytes adalah ukuran dalam byte dari array gambar.
-map_size dihitung sebagai 10 kali ukuran gambar untuk memberikan cukup ruang pada peta LMDB.

4. Membuat lingkungan LMDB baru:
-lmdb.open() digunakan untuk membuat atau membuka lingkungan LMDB.
Parameter str(lmdb_dir / f"single_lmdb") adalah jalur ke direktori -LMDB yang akan digunakan untuk menyimpan data.
-map_size menentukan ukuran maksimum peta dalam byte.

5. Memulai transaksi tulis baru:
-env.begin(write=True) memulai transaksi tulis baru di lingkungan LMDB.
-Semua operasi penulisan dilakukan dalam konteks transaksi ini.

6. Menyimpan data ke dalam LMDB:
-value diinisialisasi sebagai objek CIFAR_Image yang berisi gambar dan label.
-key adalah ID gambar yang dikonversi menjadi string dengan panjang tetap 8 karakter.
-txn.put() digunakan untuk menambahkan pasangan kunci-nilai ke dalam LMDB. Kunci (key) harus berupa string, maka dari itu key diubah menjadi string dan diencode menggunakan ASCII. Nilai (value) diserialisasi 

7. Menutup lingkungan LMDB:
env.close() 

#Storing With HDF5


import h5py

def store_single_hdf5(image, image_id, label):
    """ Stores a single image to an HDF5 file.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "w")

    # Create a dataset in the file
    dataset = file.create_dataset(
        "image", np.shape(image), h5py.h5t.STD_U8BE, data=image
    )
    meta_set = file.create_dataset(
        "meta", np.shape(label), h5py.h5t.STD_U8BE, data=label
    )
    file.close()

1. Impor pustaka yang diperlukan:

2. Definisi fungsi store_single_hdf5:
-Ini adalah definisi fungsi yang menerima tiga parameter: image, image_id, dan label.
-image adalah array gambar dengan bentuk (32, 32, 3) yang akan disimpan.
-image_id adalah ID unik untuk gambar.
-label adalah label untuk gambar

3. Membuat file HDF5 baru:
-h5py.File() digunakan untuk membuat atau membuka file HDF5.
Parameter pertama adalah nama file, di sini adalah {image_id}.
-h5 yang ditempatkan dalam direktori yang ditentukan oleh hdf5_dir.
-Parameter kedua adalah mode pembukaan file, di sini adalah "w" yang berarti kita akan membuat file baru (jika belum ada) dan menulis ke dalamnya.

4. Membuat dataset dalam file:
-file.create_dataset() digunakan untuk membuat dataset di dalam file HDF5.
-Dataset pertama dinamai "image" dan berisi gambar. np.shape(image) digunakan untuk mendapatkan bentuk gambar, dan h5py.h5t.STD_U8BE menunjukkan tipe data untuk dataset (unsigned 8-bit).
-Dataset kedua dinamai "meta" dan berisi label. np.shape(label) digunakan untuk mendapatkan bentuk label.

5. Menutup file HDF5:
file.close()

#Experiments for Storing a Single Image

_store_single_funcs = dict(
    disk=store_single_disk, lmdb=store_single_lmdb, hdf5=store_single_hdf5
)

1. Membuat kamus _store_single_funcs:
-kamus Python yang disebut _store_single_funcs.
-Kamus ini memiliki tiga kunci: 'disk', 'lmdb', dan 'hdf5'.
-Nilai dari setiap kunci adalah referensi ke fungsi yang sesuai untuk menyimpan gambar dalam format yang diinginkan.
-store_single_disk, store_single_lmdb, dan store_single_hdf5 adalah fungsi-fungsi yang telah didefinisikan sebelumnya untuk menyimpan gambar ke disk, LMDB, dan HDF5, masing-masing.


from timeit import timeit

store_single_timings = dict()

for method in ("disk", "lmdb", "hdf5"):
    t = timeit(
        "_store_single_funcs[method](image, 0, label)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    store_single_timings[method] = t
    print(f"Method: {method}, Time usage: {t}")
    
Baris kode tersebut melakukan pengukuran waktu eksekusi untuk setiap metode penyimpanan gambar (disk, LMDB, HDF5) menggunakan modul `timeit`. Mari kita jelaskan langkah-langkahnya:

1. **Membuat kamus `store_single_timings`:**
   python
   store_single_timings = dict()
   
   - Ini adalah kamus yang akan digunakan untuk menyimpan waktu eksekusi untuk setiap metode penyimpanan.

2. **Iterasi melalui setiap metode penyimpanan:**
   python
   for method in ("disk", "lmdb", "hdf5"):
   
   - Ini adalah loop yang mengulangi tiga metode penyimpanan yang tersedia: 'disk', 'lmdb', dan 'hdf5'.

3. **Mengukur waktu eksekusi untuk setiap metode:**
   python
   t = timeit(
       "_store_single_funcs[method](image, 0, label)",
       setup="image=images[0]; label=labels[0]",
       number=1,
       globals=globals(),
   )
   
   - `timeit()` digunakan untuk mengukur waktu eksekusi sebuah pernyataan Python.
   - Pernyataan yang diukur adalah `_store_single_funcs[method](image, 0, label)`, yang akan memanggil fungsi penyimpanan gambar yang sesuai berdasarkan metode yang sedang diiterasi.
   - `setup="image=images[0]; label=labels[0]"` digunakan untuk mendefinisikan variabel `image` dan `label` yang akan digunakan dalam pernyataan yang diukur.
   - `number=1` menunjukkan bahwa pernyataan akan dijalankan sekali.
   - `globals=globals()` digunakan untuk memberikan ruang lingkup global saat menjalankan pernyataan yang diukur.

4. **Menyimpan hasil pengukuran waktu:**
   python
   store_single_timings[method] = t
   
   - Waktu eksekusi untuk setiap metode disimpan dalam kamus `store_single_timings` dengan kunci yang sesuai.

5. **Mencetak waktu eksekusi untuk setiap metode:**
   python
   print(f"Method: {method}, Time usage: {t}")
   
   - Ini mencetak metode penyimpanan yang sedang diukur beserta waktu eksekusinya.

Output:

Method: disk, Time usage: 1.23456789
Method: lmdb, Time usage: 2.3456789
Method: hdf5, Time usage: 3.45678901

Ini adalah contoh output yang mungkin, di mana waktu eksekusi (dalam detik) untuk setiap metode penyimpanan ditampilkan.

#Storing Many Images

store_many_disk(images, labels):
    """ Stores an array of images to disk
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Save all the images one by one
    for i, image in enumerate(images):
        Image.fromarray(image).save(disk_dir / f"{i}.png")

    # Save all the labels to the csv file
    with open(disk_dir / f"{num_images}.csv", "w") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for label in labels:
            # This typically would be more than just one value per row
            writer.writerow([label])

def store_many_lmdb(images, labels):
    """ Stores an array of images to LMDB.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    map_size = num_images * images[0].nbytes * 10

    # Create a new LMDB DB for all the images
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), map_size=map_size)

    # Same as before â€” but let's write all the images in a single transaction
    with env.begin(write=True) as txn:
        for i in range(num_images):
            # All key-value pairs need to be Strings
            value = CIFAR_Image(images[i], labels[i])
            key = f"{i:08}"
            txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()

def store_many_hdf5(images, labels):
    """ Stores an array of images to HDF5.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "w")

    # Create a dataset in the file
    dataset = file.create_dataset(
        "images", np.shape(images), h5py.h5t.STD_U8BE, data=images
    )
    meta_set = file.create_dataset(
        "meta", np.shape(labels), h5py.h5t.STD_U8BE, data=labels
    )
    file.close()

Fungsi-fungsi ini bertujuan untuk menyimpan banyak gambar ke dalam format penyimpanan yang berbeda (disk, LMDB, HDF5). Mari kita jelaskan masing-masing dengan singkat:

### Fungsi `store_many_disk`:
1. **Menghitung jumlah gambar:** 
   python
   num_images = len(images)
   
   - Variabel `num_images` menyimpan jumlah gambar yang akan disimpan.

2. **Menyimpan setiap gambar ke disk:** 
   python
   for i, image in enumerate(images):
       Image.fromarray(image).save(disk_dir / f"{i}.png")
   
   - Ini melakukan iterasi melalui setiap gambar dan menyimpannya ke disk sebagai file PNG.

3. **Menyimpan label ke dalam file CSV:** 
   python
   with open(disk_dir / f"{num_images}.csv", "w") as csvfile:
       writer = csv.writer(
           csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
       )
       for label in labels:
           writer.writerow([label])
   
   - Ini membuka file CSV dan menulis setiap label ke dalamnya.

### Fungsi `store_many_lmdb`:
1. **Menghitung ukuran peta untuk LMDB:** 
   python
   map_size = num_images * images[0].nbytes * 10
   
   - Ukuran peta dihitung berdasarkan jumlah gambar dan ukuran gambar pertama.

2. **Membuka lingkungan LMDB:** 
   python
   env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), map_size=map_size)
   
   - Lingkungan LMDB baru dibuka untuk menyimpan semua gambar.

3. **Menyimpan semua gambar ke dalam LMDB:** 
   python
   with env.begin(write=True) as txn:
       for i in range(num_images):
           value = CIFAR_Image(images[i], labels[i])
           key = f"{i:08}"
           txn.put(key.encode("ascii"), pickle.dumps(value))
   
   - Semua gambar dan labelnya disimpan dalam satu transaksi tulis LMDB.

### Fungsi `store_many_hdf5`:
1. **Membuka file HDF5:** 
   python
   file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "w")
   
   - File HDF5 baru dibuat untuk menyimpan semua gambar.

2. **Membuat dataset dalam file:** 
   python
   dataset = file.create_dataset(
       "images", np.shape(images), h5py.h5t.STD_U8BE, data=images
   )
   meta_set = file.create_dataset(
       "meta", np.shape(labels), h5py.h5t.STD_U8BE, data=labels
   )
   
   - Dataset "images" dan "meta" dibuat untuk menyimpan gambar dan labelnya dalam file HDF5.

3. **Menutup file HDF5:** 
   python
   file.close()
   
   - File HDF5 ditutup setelah selesai digunakan.

Output: Tidak ada output yang langsung terlihat dari fungsi-fungsi ini. Mereka akan menyimpan gambar-gambar dan labelnya sesuai dengan format penyimpanan yang ditentukan.

#Preparing the Dataset


cutoffs = [10, 100, 1000, 10000, 100000]

# Let's double our images so that we have 100,000
images = np.concatenate((images, images), axis=0)
labels = np.concatenate((labels, labels), axis=0)

# Make sure you actually have 100,000 images and labels
print(np.shape(images))
print(np.shape(labels))

Berikut adalah langkah-langkah dan output dari potongan kode tersebut:

### Langkah-langkah:
1. **Membuat daftar `cutoffs`:**
   python
   cutoffs = [10, 100, 1000, 10000, 100000]
   
   - `cutoffs` adalah daftar yang berisi nilai-nilai yang akan digunakan sebagai batas jumlah gambar.

2. **Menggandakan jumlah gambar:**
   python
   images = np.concatenate((images, images), axis=0)
   labels = np.concatenate((labels, labels), axis=0)
   
   - `np.concatenate()` digunakan untuk menggabungkan dua larik gambar dan label secara berurutan ke dalam satu larik.
   - `axis=0` menunjukkan bahwa penggabungan dilakukan menurut baris (menambahkan gambar dan label ke bawah).

3. **Memastikan jumlah gambar dan label:**
   python
   print(np.shape(images))
   print(np.shape(labels))
   
   - `np.shape()` digunakan untuk mendapatkan dimensi dari larik gambar dan label.
   - Ini mencetak dimensi dari larik gambar dan label setelah proses penggandaan.

### Output (contoh):

(200000, 32, 32, 3)
(200000,)

- Output ini menunjukkan bahwa setelah penggandaan, kita sekarang memiliki 200.000 gambar dengan dimensi (32, 32, 3) dan 200.000 label.

#ExperimenT for Storing Many Images

_store_many_funcs = dict(
    disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
)

from timeit import timeit

store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_store_many_funcs[method](images_, labels_)",
            setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
            number=1,
            globals=globals(),
        )
        store_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, Time usage: {t}")

Langkah-langkah dan output dari potongan kode ini adalah sebagai berikut:

### Langkah-langkah:
1. **Membuat kamus `_store_many_funcs`:**
   python
   _store_many_funcs = dict(
       disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
   )
   
   - Ini adalah kamus yang berisi fungsi-fungsi untuk menyimpan banyak gambar ke dalam berbagai format penyimpanan.

2. **Menginisialisasi kamus `store_many_timings`:**
   python
   store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}
   
   - Ini adalah kamus yang akan digunakan untuk menyimpan waktu eksekusi untuk setiap metode penyimpanan dan setiap nilai `cutoff`.

3. **Iterasi melalui setiap `cutoff` dan metode penyimpanan:**
   python
   for cutoff in cutoffs:
       for method in ("disk", "lmdb", "hdf5"):
   
   - Ini adalah loop bersarang yang mengulangi setiap nilai `cutoff` dan metode penyimpanan.

4. **Mengukur waktu eksekusi untuk setiap metode penyimpanan pada setiap `cutoff`:**
   python
   t = timeit(
       "store_many_funcs[method](images, labels_)",
       setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
       number=1,
       globals=globals(),
   )
   
   - `timeit()` digunakan untuk mengukur waktu eksekusi untuk menyimpan gambar menggunakan metode dan `cutoff` yang sedang diuji.
   - Pernyataan yang diukur adalah `_store_many_funcs[method](images_, labels_)`, yang akan memanggil fungsi penyimpanan gambar yang sesuai berdasarkan metode.
   - `setup="images_=images[:cutoff]; labels_=labels[:cutoff]"` digunakan untuk mendefinisikan variabel `images_` dan `labels_` yang akan digunakan dalam pernyataan yang diukur. Variabel tersebut diisi dengan sebagian dari gambar dan label sesuai dengan nilai `cutoff`.
   - `number=1` menunjukkan bahwa pernyataan akan dijalankan sekali.
   - `globals=globals()` digunakan untuk memberikan ruang lingkup global saat menjalankan pernyataan yang diukur.

5. **Menyimpan hasil pengukuran waktu:**
   python
   store_many_timings[method].append(t)
   
   - Waktu eksekusi untuk setiap metode dan `cutoff` disimpan dalam kamus `store_many_timings` dengan kunci yang sesuai.

6. **Mencetak waktu eksekusi untuk setiap metode dan `cutoff`:**
   python
   print(f"Method: {method}, Time usage: {t}")
   
   - Ini mencetak metode penyimpanan yang sedang diukur bersama dengan waktu eksekusinya.

### Output (contoh):

Method: disk, Time usage: 5.67890123
Method: lmdb, Time usage: 6.78901234
Method: hdf5, Time usage: 7.89012345


import matplotlib.pyplot as plt

def plot_with_legend(
    x_range, y_data, legend_labels, x_label, y_label, title, log=False
):
    """ Displays a single plot with multiple datasets and matching legends.
        Parameters:
        --------------
        x_range         list of lists containing x data
        y_data          list of lists containing y values
        legend_labels   list of string legend labels
        x_label         x axis label
        y_label         y axis label
    """
    plt.style.use("seaborn-whitegrid")
    plt.figure(figsize=(10, 7))

    if len(y_data) != len(legend_labels):
        raise TypeError(
            "Error: number of data sets does not match number of labels."
        )

    all_plots = []
    for data, label in zip(y_data, legend_labels):
        if log:
            temp, = plt.loglog(x_range, data, label=label)
        else:
            temp, = plt.plot(x_range, data, label=label)
        all_plots.append(temp)

    plt.title(title)
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend(handles=all_plots)
    plt.show()

# Getting the store timings data to display
disk_x = store_many_timings["disk"]
lmdb_x = store_many_timings["lmdb"]
hdf5_x = store_many_timings["hdf5"]

plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Storage time",
    log=False,
)

plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Log storage time",
    log=True,
)

Berikut adalah langkah-langkah dan output dari potongan kode tersebut:

### Langkah-langkah:
1. **Mendefinisikan fungsi `plot_with_legend`:**
   - Fungsi ini menghasilkan plot tunggal dengan beberapa kumpulan data dan legenda yang sesuai.
   - Menerima beberapa parameter seperti `x_range`, `y_data`, `legend_labels`, `x_label`, `y_label`, `title`, dan opsional `log` untuk menentukan apakah plot menggunakan skala logaritmik atau tidak.

2. **Mengatur gaya plot dan ukuran:**
   python
   plt.style.use("seaborn-whitegrid")
   plt.figure(figsize=(10, 7))
   
   - Mengatur gaya plot dan ukuran gambar untuk plot.

3. **Loop melalui data dan membuat plot:**
   python
   for data, label in zip(y_data, legend_labels):
       if log:
           temp, = plt.loglog(x_range, data, label=label)
       else:
           temp, = plt.plot(x_range, data, label=label)
       all_plots.append(temp)
   
   - Ini melakukan iterasi melalui data dan label yang disediakan.
   - Membuat plot menggunakan `plt.plot()` atau `plt.loglog()` tergantung pada nilai `log`.

4. **Menambahkan judul dan label sumbu:**
   python
   plt.title(title)
   plt.xlabel(x_label)
   plt.ylabel(y_label)
   

5. **Menambahkan legenda dan menampilkan plot:**
   python
   plt.legend(handles=all_plots)
   plt.show()
   
   - Ini menambahkan legenda berdasarkan plot yang telah dibuat dan menampilkan plot.

6. **Mengambil data waktu penyimpanan untuk plot:**
   python
   disk_x = store_many_timings["disk"]
   lmdb_x = store_many_timings["lmdb"]
   hdf5_x = store_many_timings["hdf5"]
   
   - Data waktu penyimpanan dari kamus `store_many_timings` diambil untuk masing-masing metode penyimpanan.

7. **Membuat plot:**
   python
   plot_with_legend(
       cutoffs,
       [disk_x, lmdb_x, hdf5_x],
       ["PNG files", "LMDB", "HDF5"],
       "Number of images",
       "Seconds to store",
       "Storage time",
       log=False,
   )
   
   - Ini memanggil fungsi `plot_with_legend` dengan parameter yang sesuai untuk membuat plot waktu penyimpanan untuk setiap metode penyimpanan.

8. **Membuat plot skala logaritmik:**
   python
   plot_with_legend(
       cutoffs,
       [disk_x, lmdb_x, hdf5_x],
       ["PNG files", "LMDB", "HDF5"],
       "Number of images",
       "Seconds to store",
       "Log storage time",
       log=True,
   )
   
   - Ini memanggil fungsi `plot_with_legend` dengan parameter yang sama namun dengan `log=True` untuk membuat plot waktu penyimpanan dengan skala logaritmik.

### Output:
- Output berupa dua plot yang menampilkan waktu penyimpanan untuk setiap metode penyimpanan dalam detik, dengan sumbu x berlabel "Number of images" dan sumbu y berlabel "Seconds to store". Satu plot menggunakan skala linear dan yang lainnya menggunakan skala logaritmik. Legenda menunjukkan metode penyimpanan yang sesuai.

#Reading a Single Image

Reading From Disk

def read_single_disk(image_id):
    """ Stores a single image to disk.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    image = np.array(Image.open(disk_dir / f"{image_id}.png"))

    with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        label = int(next(reader)[0])

    return image, label

Berikut adalah penjelasan langkah demi langkah dari fungsi `read_single_disk`:

1. **Membaca gambar dari disk:**
   python
   image = np.array(Image.open(disk_dir / f"{image_id}.png"))
   
   - Menggunakan `Image.open()` dari modul PIL untuk membuka gambar yang disimpan di disk.
   - `disk_dir / f"{image_id}.png"` adalah path lengkap ke file gambar yang akan dibuka.
   - Mengonversi gambar yang dibuka menjadi larik NumPy menggunakan `np.array()`.

2. **Membaca label dari file CSV:**
   python
   with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
       reader = csv.reader(
           csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
       )
       label = int(next(reader)[0])
   
   - Membuka file CSV yang berisi label terkait dengan gambar yang sama.
   - Menggunakan `csv.reader()` untuk membaca isi file CSV.
   - `next(reader)[0]` digunakan untuk membaca baris pertama dari file CSV dan mengambil nilai labelnya.
   - Mengonversi label yang dibaca menjadi tipe data integer.

3. **Mengembalikan gambar dan label:**
   python
   return image, label
   
   - Mengembalikan gambar dan label sebagai keluaran dari fungsi.

Reading From LMDB

def read_single_lmdb(image_id):
    """ Stores a single image to LMDB.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Encode the key the same way as we stored it
        data = txn.get(f"{image_id:08}".encode("ascii"))
        # Remember it's a CIFAR_Image object that is loaded
        cifar_image = pickle.loads(data)
        # Retrieve the relevant bits
        image = cifar_image.get_image()
        label = cifar_image.label
    env.close()

    return image, label

Berikut adalah penjelasan langkah demi langkah dari fungsi `read_single_lmdb`:

1. **Membuka lingkungan LMDB:**
   python
   env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)
   
   - `lmdb.open()` digunakan untuk membuka lingkungan LMDB dengan mode hanya baca (`readonly=True`).
   - `lmdb_dir / f"single_lmdb"` adalah path lengkap ke lingkungan LMDB yang akan dibuka.

2. **Memulai transaksi baca baru:**
   python
   with env.begin() as txn:
   
   - `env.begin()` digunakan untuk memulai transaksi baca di lingkungan LMDB.

3. **Mendapatkan data dari kunci yang sesuai:**
   python
   data = txn.get(f"{image_id:08}".encode("ascii"))
   
   - Menggunakan `txn.get()` untuk mengambil data yang terkait dengan kunci gambar yang sesuai dari lingkungan LMDB.
   - Kunci diencode ke dalam format yang sesuai dengan cara penyimpanan awal.

4. **Menguraikan objek CIFAR_Image:**
   python
   cifar_image = pickle.loads(data)
   
   - Menggunakan `pickle.loads()` untuk menguraikan data yang diperoleh dari LMDB.
   - Karena data yang disimpan adalah objek `CIFAR_Image`, kita mengembalikan objek tersebut.

5. **Mengambil gambar dan label dari objek CIFAR_Image:**
   python
   image = cifar_image.get_image()
   label = cifar_image.label
   
   - Memanggil metode `get_image()` dari objek `cifar_image` untuk mendapatkan gambar.
   - Mengambil label dari objek `cifar_image`.

6. **Menutup transaksi dan lingkungan LMDB:**
   python
   env.close()
   
   - Menutup transaksi dan lingkungan LMDB setelah selesai digunakan.

7. **Mengembalikan gambar dan label:**
   python
   return image, label
   
   - Mengembalikan gambar dan label sebagai keluaran dari fungsi.


Reading From HDF5

def read_single_hdf5(image_id):
    """ Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")

    image = np.array(file["/image"]).astype("uint8")
    label = int(np.array(file["/meta"]).astype("uint8"))

    return image, label


Berikut adalah penjelasan langkah demi langkah dari fungsi `read_single_hdf5`:

1. **Membuka file HDF5:**
   python
   file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")
   
   - `h5py.File()` digunakan untuk membuka file HDF5 dengan mode baca-tulis ("r+").
   - `hdf5_dir / f"{image_id}.h5"` adalah path lengkap ke file HDF5 yang akan dibuka.

2. **Membaca gambar dari dataset "image":**
   python
   image = np.array(file["/image"]).astype("uint8")
   
   - Menggunakan `np.array()` untuk mengonversi dataset "image" dari file HDF5 menjadi larik NumPy.
   - `.astype("uint8")` digunakan untuk memastikan tipe data gambar adalah unsigned integer 8-bit.

3. **Membaca label dari dataset "meta":**
   python
   label = int(np.array(file["/meta"]).astype("uint8"))
   
   - Menggunakan `np.array()` untuk mengonversi dataset "meta" dari file HDF5 menjadi larik NumPy.
   - `.astype("uint8")` digunakan untuk memastikan tipe data label adalah unsigned integer 8-bit.
   - Mengonversi larik NumPy menjadi integer untuk label.

4. **Menutup file HDF5:**
   python
   file.close()
   
   - Menutup file HDF5 setelah selesai digunakan.

5. **Mengembalikan gambar dan label:**
   python
   return image, label
   
   - Mengembalikan gambar dan label sebagai keluaran dari fungsi.


_read_single_funcs = dict(
    disk=read_single_disk, lmdb=read_single_lmdb, hdf5=read_single_hdf5
)



1. disk=read_single_disk berarti bahwa fungsi read_single_disk akan dihubungkan dengan kunci string 'disk' dalam kamus _read_single_funcs.
2. lmdb=read_single_lmdb berarti bahwa fungsi read_single_lmdb akan dihubungkan dengan kunci string 'lmdb' dalam kamus _read_single_funcs.
4. hdf5=read_single_hdf5 brarti bahwa fungsi read_single_hdf5 akan dihubungkan dengan kunci string 'hdf5' dalam kamus _read_single_funcs.

#Experiment for Reading a Single Image

from timeit import timeit

read_single_timings = dict()

for method in ("disk", "lmdb", "hdf5"):
    t = timeit(
        "_read_single_funcs[method](0)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    read_single_timings[method] = t
    print(f"Method: {method}, Time usage: {t}")

Potongan kode ini mengukur waktu yang dibutuhkan untuk membaca satu gambar beserta labelnya dari setiap metode penyimpanan yang tersedia, yaitu "disk", "lmdb", dan "hdf5". Berikut adalah penjelasan langkah demi langkah dan outputnya:

### Langkah-langkah:
1. **Iterasi melalui setiap metode penyimpanan:**
   python
   for method in ("disk", "lmdb", "hdf5"):
   
   - Ini adalah loop yang mengulangi setiap metode penyimpanan yang tersedia.

2. **Mengukur waktu eksekusi untuk membaca gambar:**
   python
   t = timeit(
       "_read_single_funcs ",
       setup="image=images[0]; label=labels[0]",
       number=1,
       globals=globals(),
   )
   
   - `timeit()` digunakan untuk mengukur waktu eksekusi dari pemanggilan fungsi membaca satu gambar menggunakan metode yang sedang diuji.
   - Pernyataan yang diukur adalah `_read_single_funcs `, yang akan memanggil fungsi membaca gambar yang sesuai berdasarkan metode.
   - `setup="image=images[0]; label=labels[0]"` digunakan untuk mendefinisikan variabel `image` dan `label` yang akan digunakan dalam pernyataan yang diukur. Variabel tersebut diisi dengan gambar pertama dan label pertama dari data yang dimuat.
   - `number=1` menunjukkan bahwa pernyataan akan dijalankan sekali.

3. **Menyimpan hasil pengukuran waktu:**
   python
   read_single_timings[method] = t
   
   - Waktu eksekusi untuk setiap metode disimpan dalam kamus `read_single_timings` dengan kunci yang sesuai.

4. **Mencetak waktu eksekusi untuk setiap metode:**
   python
   print(f"Method: {method}, Time usage: {t}")
   
   - Ini mencetak metode penyimpanan yang sedang diuji bersama dengan waktu eksekusinya.

### Output (contoh):

Method: disk, Time usage: 0.123456
Method: lmdb, Time usage: 0.234567
Method: hdf5, Time usage: 0.345678


#Reading Many Images

Adjusting the Code for Many Images

def read_many_disk(num_images):
    """ Reads image from disk.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []

    # Loop over all IDs and read each image in one by one
    for image_id in range(num_images):
        images.append(np.array(Image.open(disk_dir / f"{image_id}.png")))

    with open(disk_dir / f"{num_images}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for row in reader:
            labels.append(int(row[0]))
    return images, labels

def read_many_lmdb(num_images):
    """ Reads image from LMDB.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Read all images in one single transaction, with one lock
        # We could split this up into multiple transactions if needed
        for image_id in range(num_images):
            data = txn.get(f"{image_id:08}".encode("ascii"))
            # Remember that it's a CIFAR_Image object 
            # that is stored as the value
            cifar_image = pickle.loads(data)
            # Retrieve the relevant bits
            images.append(cifar_image.get_image())
            labels.append(cifar_image.label)
    env.close()
    return images, labels

def read_many_hdf5(num_images):
    """ Reads image from HDF5.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []

    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "r+")

    images = np.array(file["/images"]).astype("uint8")
    labels = np.array(file["/meta"]).astype("uint8")

    return images, labels

_read_many_funcs = dict(
    disk=read_many_disk, lmdb=read_many_lmdb, hdf5=read_many_hdf5
)

Berikut adalah penjelasan singkat langkah demi langkah dari potongan kode di atas:

1. **Fungsi `read_many_disk`:**
   - Membaca sejumlah gambar dan labelnya dari disk.
   - Membuka setiap gambar secara individu menggunakan iterasi melalui ID gambar.
   - Membuka file CSV yang berisi label-label tersebut.
   - Mengembalikan larik gambar dan larik label.

2. **Fungsi `read_many_lmdb`:**
   - Membaca sejumlah gambar dan labelnya dari LMDB.
   - Membuka lingkungan LMDB yang sesuai dengan jumlah gambar yang akan dibaca.
   - Memulai transaksi baca.
   - Mengambil data dari LMDB untuk setiap gambar.
   - Mengembalikan larik gambar dan larik label.

3. **Fungsi `read_many_hdf5`:**
   - Membaca sejumlah gambar dan labelnya dari file HDF5.
   - Membuka file HDF5 yang sesuai dengan jumlah gambar yang akan dibaca.
   - Membaca dataset gambar dan label dari file HDF5.
   - Mengembalikan larik gambar dan larik label.

4. **Kamus `_read_many_funcs`:**
   - Kamus ini memetakan nama metode penyimpanan ("disk", "lmdb", "hdf5") ke fungsi-fungsi yang sesuai untuk membaca sejumlah gambar dan labelnya dari masing-masing metode penyimpanan.

Experiment for Reading Many Images


from timeit import timeit

read_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_read_many_funcs[method](num_images)",
            setup="num_images=cutoff",
            number=1,
            globals=globals(),
        )
        read_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")


Berikut adalah penjelasan singkat langkah demi langkah dari potongan kode di atas:

1. **Iterasi melalui nilai-nilai cutoff:**
   python
   for cutoff in cutoffs:
   
   - Loop ini mengulangi setiap nilai cutoff yang telah ditentukan sebelumnya.

2. **Iterasi melalui metode penyimpanan:**
   python
   for method in ("disk", "lmdb", "hdf5"):
   
   - Loop ini mengulangi setiap metode penyimpanan yang tersedia, yaitu "disk", "lmdb", dan "hdf5".

3. **Mengukur waktu untuk membaca banyak gambar dan label:**
   python
   t = timeit(
       "_read_many_funcs[method](num_images)",
       setup="num_images=cutoff",
       number=1,
       globals=globals(),
   )
   
   - `timeit()` digunakan untuk mengukur waktu eksekusi dari pemanggilan fungsi untuk membaca banyak gambar dan label menggunakan metode yang sedang diuji.
   - Pernyataan yang diukur adalah `_read_many_funcs[method](num_images)`, yang akan memanggil fungsi membaca banyak gambar dan label yang sesuai berdasarkan metode.
   - `setup="num_images=cutoff"` digunakan untuk menyiapkan jumlah gambar yang akan dibaca sesuai dengan nilai cutoff yang sedang diuji.
   - `number=1` menunjukkan bahwa pernyataan akan dijalankan sekali.

4. **Menyimpan hasil pengukuran waktu:**
   python
   read_many_timings[method].append(t)
   
   - Waktu eksekusi untuk setiap metode dan setiap nilai cutoff disimpan dalam kamus `read_many_timings` dengan kunci yang sesuai.

5. **Mencetak informasi tentang metode, jumlah gambar, dan waktu eksekusi:**
   python
   print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")
   
   - Ini mencetak informasi tentang metode penyimpanan yang sedang diuji, jumlah gambar yang sedang diproses, dan waktu eksekusi yang diukur.

#A More Critical Look at Implementation

# Slightly slower
for i in range(len(dataset)):
    # Read the ith value in the dataset, one at a time
    do_something_with(dataset[i])

# This is better
data = dataset[:]
for d in data:
    do_something_with(d)

Potongan kode tersebut adalah contoh penggunaan slicing dalam Python untuk mengoptimalkan iterasi melalui suatu dataset. Berikut penjelasan singkatnya:

1. **Iterasi dengan Indeks:**
   python
   for i in range(len(dataset)):
       do_something_with(dataset[i])
   
   - Ini adalah cara tradisional untuk mengiterasi melalui setiap elemen dalam dataset dengan menggunakan indeks.
   - Pada setiap iterasi, nilai indeks digunakan untuk mengakses elemen dataset menggunakan indexing.
   - Metode ini cukup lambat karena pada setiap iterasi, Python harus mengakses elemen dataset menggunakan indeks.

2. **Iterasi dengan Slicing:**
   python
   data = dataset[:]
   for d in data:
       do_something_with(d)
   ```
   - Ini adalah cara yang lebih baik dan lebih efisien untuk mengiterasi melalui setiap elemen dalam dataset.
   - dataset[:] digunakan untuk membuat salinan dataset secara keseluruhan.
   - Salinan dataset kemudian disimpan dalam variabel data.
   - Iterasi dilakukan melalui data, yang merupakan salinan lengkap dari dataset.
   - Dengan menggunakan slicing, Python tidak perlu mengakses elemen dataset menggunakan indeks pada setiap iterasi, yang membuatnya lebih cepat dan lebih efisien.
